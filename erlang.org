* erlang 後端實現

正在進行中。

*** 實體對象
Erlang 是函數式語言，沒有對象的概念。在 Tightrope erlang 實現中，用 record 來實
現數據結構。實體對象的定義保存在對應的 hrl 文件中，方便各個模塊調用。

#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/erlang.scm
  <<utility>>

  (define (generate-erlang-include field)
    (if (custom-type? (field-type field))
        (string-append "-include(\"" (>erlang-name (symbol->string (field-type field))) ".hrl\").\n")
        ""))

  (define (generate-erlang-field-declare field)
    (let ((name (>erlang-name (field-name field)))
          (type (field-type field)))
      (if (array-type? type)
          (let ((base-type (array-base-type type)))
            (cond
             ((custom-type? base-type) (string-append name "::[#" (>erlang-module-name (symbol->string base-type)) "{}],"))
             (else (string-append name "::[" (>erlang-type type) "],"))))
          (cond
           ((custom-type? type) (string-append name "::#" (>erlang-module-name (symbol->string type)) "{},"))
           (else (string-append name "::" (>erlang-type type) ","))))))

  (define (generate-erlang-entity struct dir)
    (let ((name (struct-name struct))
          (fields (struct-fields struct)))
      (let ((includes (strcat (map generate-erlang-include fields)))
            (record-start "-record(")
            (record-stop ").")
            (record-name (>erlang-module-name name))
            (field-decls (strcat (map generate-erlang-field-declare fields))))
        (with-output-to-file
            (string-append dir (>erlang-module-name name) ".hrl")
          (lambda ()
            (write-string (string-append includes record-start record-name ", {" (substring field-decls 0 (- (string-length field-decls) 1)) "}" record-stop)))
          (list 'replace)))))

  (define (generate-erlang-entities env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (for-each
       (lambda (entity) (generate-erlang-entity entity path))
       (get-structs env))))
#+end_src

*** 序列化與反序列化

**** 編碼器

編碼器分爲三個主要步驟：
1. 分析對象屬性，沒有設置的屬性，或者默認值爲 0 的屬性被跳過，同時轉換 string,
   數組，自定義結構爲二進制表達；
2. 設置非對象屬性的值；
3. 如果有的話，設置對象(包括字符串)屬性的二進制數據。

#+begin_src scheme :exports code :noweb no :tangle /dev/shm/tightrope-build/erlang.scm
  (define (generate-erlang-record-match name fields)
    (let loop ((fs fields)
               (attrs '()))
      (if (null? fs)
          (if (null? attrs)
              ""
              (let ((attrs-string (strcat (reverse attrs))))
                (string-append "#" name "{" (substring attrs-string 0 (- (string-length attrs-string) 2)) "}")))
          (loop (cdr fs) (cons (string-append (>erlang-name (field-name (car fs))) " = " (>erlang-var-name (field-name (car fs))) ", ") attrs)))))

  (define (generate-erlang-object-array-to-binary-recursive field)
    (let ((type (>erlang-name (symbol->string (array-base-type (field-type field))))))
      (let ((spec (string-append "-spec " type "_array_to_binary([#" type "{}]) -> binary().\n"))
            (sign (string-append type "_array_to_binary(X) ->\n"))
            (body (indent-line 4 type "_array_to_binary(X, <<>>)."))
            (spec-recr (string-append "-spec " type "_array_to_binary([#" type "{}], binary()) -> binary().\n"))
            (sign-recr (string-append type "_array_to_binary(X, Acc) ->\n"))
            (body-recr (string-append
                        (indent-line 4 "if")
                        (indent-line 8 "length(X) == 0 ->")
                        (indent-line 12 "Acc;")
                        (indent-line 8 "true ->")
                        (indent-line 12 (>erlang-var-name type) " = hd(X),")
                        (indent-line 12 "Bin = " type ":encode(" (>erlang-var-name type) "),")
                        (indent-line 12 "Size = size(Bin),")
                        (indent-line 12 type "_array_to_binary(tl(X), <<Acc/binary, Size:32, Bin/binary>>)")
                        (indent-line 4 "end."))))
        (string-append spec sign body spec-recr sign-recr body-recr))))

  (define (generate-erlang-object-array-to-binary struct)
    (let ((name (struct-name struct))
          (fields (filter (lambda (x) (let ((type (field-type x))) (and (array-type? type) (custom-type? (array-base-type type))))) (struct-fields struct))))
      (strcat (map generate-erlang-object-array-to-binary-recursive fields))))

  (define (generate-erlang-analyzer-field sname field base-indent)
    (let ((tag (number->string (field-tag field)))
          (fname (field-name field))
          (type (field-type field)))
      (let ((accessor (generate-erlang-record-accessor sname fname)))
        (if (array-type? type)
            (let ((base-type (array-base-type type)))
              (cond
               ((eq? base-type 'byte)
                (string-append
                 (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
                 (indent-line (+ base-indent 4) "ObjBin = list_to_binary(" accessor "),")
                 (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [ObjBin | ObjBins]});")))
               ((eq? base-type 'short)
                (string-append
                 (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
                 (indent-line (+ base-indent 4) "ObjBin = tightrope:number_array_to_binary(" accessor ", ?SHORT_SIZE),")
                 (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [ObjBin | ObjBins]});")))
               ((eq? base-type 'int)
                (string-append
                 (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
                 (indent-line (+ base-indent 4) "ObjBin = tightrope:number_array_to_binary(" accessor ", ?INT_SIZE),")
                 (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [ObjBin | ObjBins]});")))
               ((eq? base-type 'long)
                (string-append
                 (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
                 (indent-line (+ base-indent 4) "ObjBin = tightrope:number_array_to_binary(" accessor ", ?LONG_SIZE),")
                 (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [ObjBin | ObjBins]});")))
               ((eq? base-type 'string)
                (string-append
                 (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
                 (indent-line (+ base-indent 4) "ObjBin = tightrope:string_array_to_binary(" accessor "),")
                 (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [ObjBin | ObjBins]});")))
               ((custom-type? base-type)
                (string-append
                 (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
                 (indent-line (+ base-indent 4) "ObjBin = " (>erlang-name (symbol->string base-type)) "_array_to_binary(" accessor "),")
                 (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [ObjBin | ObjBins]});")))
               (else
                (string-append
                 (indent-line base-indent "Tag == " tag " ->")
                 (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), Env);")))))
            (cond
             ((eq? type 'string)
              (string-append
               (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
               (indent-line (+ base-indent 4) "StrBin = unicode:characters_to_binary(" accessor "),")
               (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [StrBin | ObjBins]});")))
             ((custom-type? type)
              (string-append
               (indent-line base-indent "Tag == " tag ", " accessor " /= nil ->")
               (indent-line (+ base-indent 4) "ObjBin = " (>erlang-module-name (symbol->string type)) ":encode(" accessor "),")
               (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), #env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags], objbins = [ObjBin | ObjBins]});")))
             ((eq? type 'byte)
              (string-append
               (indent-line base-indent "Tag == " tag ", " accessor " /= 0 ->")
               (indent-line (+ base-indent 4) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), Env#env{count = Count + 1, tags = [" tag " | Tags]});")))
             (else
              (string-append
               (indent-line base-indent "Tag == " tag ", " accessor " /= 0 ->")
               (indent-line (+ base-indent 4) "if")
               (indent-line (+ base-indent 8) "0 < " accessor ", " accessor " < 16383 ->")
               (indent-line (+ base-indent 12) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), Env#env{count = Count + 1, tags = [" tag " | Tags], dtags = [" tag " | DTags]});")
               (indent-line (+ base-indent 8) " true ->")
               (indent-line (+ base-indent 12) "analyzer(" (>erlang-var-name sname) ", tl(CheckTags), Env#env{count = Count + 1, tags = [" tag " | Tags]})")
               (indent-line (+ base-indent 4) "end;"))))))))

  (define (generate-erlang-analyzer-recursive struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((spec (indent-line 0 "-spec analyzer(#" name "{}, [non_neg_integer()], #env{}) -> #env{}."))
            (sign (indent-line 0 "analyzer(" (>erlang-var-name name) ", CheckTags, Env) ->"))
            (body (string-append
                   (indent-line 4 "#env{count = Count, tags = Tags, dtags = DTags, objbins = ObjBins} = Env,")
                   (indent-line 4 "if")
                   (indent-line 8 "length(CheckTags) == 0 ->")
                   (indent-line 12 "Env#env{tags = lists:reverse(Tags), dtags = lists:reverse(DTags), objbins = lists:reverse(ObjBins)};")
                   (indent-line 8 "true ->")
                   (indent-line 12 "Tag = hd(CheckTags),")
                   (indent-line 12 "if")
                   (strcat (map (lambda (x) (generate-erlang-analyzer-field name x 16)) fields))
                   (indent-line 16 "true ->")
                   (indent-line 20 "analyzer(" (>erlang-var-name name) ", tl(CheckTags), Env)")
                   (indent-line 12 "end")
                   (indent-line 4 "end."))))
        (string-append spec sign body))))

  (define (generate-erlang-analyzer struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let* ((spec (indent-line 0 "-spec analyzer(#" name "{}) -> #env{}."))
             (tags (strcat (map (lambda(x) (string-append (number->string (field-tag x)) ", ")) fields)))
             (body (string-append
                    (indent-line 0 "analyzer(" (>erlang-var-name name) ") ->")
                    (indent-line 4 "analyzer(" (>erlang-var-name name) ", [" (if (> (string-length tags) 1) (substring tags 0 (- (string-length tags) 2)) "") "], #env{count = 0, tags = [], dtags = [], objbins = []}).")))
             (recr (generate-erlang-analyzer-recursive struct)))
        (string-append spec body recr))))

  (define (generate-erlang-set-field sname field base-indent)
    (let ((fname (>erlang-name (field-name field)))
          (type (field-type field))
          (tag (number->string (field-tag field))))
      (string-append
       (indent-line base-indent tag " ->")
       (if (primitive-type? type)
           (let ((vname (>erlang-var-name fname)))
             (string-append
              (indent-line (+ base-indent 4) "if")
              (indent-line (+ base-indent 8) "0 < " vname ", " vname " < 16383 ->")
              (indent-line (+ base-indent 12) "set_fields(<<Tmp/binary, ((" vname " + 1) * 2):16>>, X, tl(Tags), Tag);")
              (indent-line (+ base-indent 8) "true ->")
              (indent-line (+ base-indent 12) "set_fields(<<Tmp/binary, 0:16>>, X, tl(Tags), Tag)")
              (indent-line (+ base-indent 4) "end;")))
           (indent-line (+ base-indent 4) "set_fields(<<Tmp/binary, 0:16>>, X, tl(Tags), Tag);")))))

  (define (generate-erlang-set-fields-recursive struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let* ((spec (string-append "-spec set_fields(binary(), #" name "{}, [non_neg_integer()], integer()) -> binary().\n"))
             (sign "set_fields(Buf, X, Tags, LastTag) ->\n")
             (action (strcat (map (lambda(x) (generate-erlang-set-field name x 16)) fields)))
             (body (string-append
                    (indent-line 04 "Length = length(Tags),")
                    (indent-line 04 "if")
                    (indent-line 08 "Length == 0 ->")
                    (indent-line 12 "Buf;")
                    (indent-line 08 "true ->")
                    (indent-line 12 (string-append (generate-erlang-record-match name (primitive-fields fields)) " = X,"))
                    (indent-line 12 "Tag = hd(Tags),")
                    (indent-line 12 "Tmp = if")
                    (indent-line 22 "LastTag + 1 /= Tag ->")
                    (indent-line 26 "T = (Tag - LastTag - 1) * 2 + 1,")
                    (indent-line 26 "<<Buf/binary, T:16>>;")
                    (indent-line 22 "true ->")
                    (indent-line 26 "Buf")
                    (indent-line 18 "end,")
                    (indent-line 12 "case Tag of")
                    (string-append (substring action 0 (- (string-length action) 2)) "\n")
                    (indent-line 12 "end")
                    (indent-line 4 "end."))))
        (string-append spec sign body))))

  (define (generate-erlang-set-fields struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((spec (string-append "-spec set_fields(binary(), #" name "{}, #env{}) -> binary().\n"))
            (sign "set_fields(Buf, X, Env) ->\n")
            (body (if (and (= (length fields) 1) (= (field-tag (car fields)) 0))
                      (string-append
                       (indent-line 4 "#env{tags = Tags} = Env,")
                       (indent-line 4 "set_fields(Buf, X, Tags, -1)."))
                      (string-append
                       (indent-line 4 "#env{tags = Tags} = Env,")
                       (indent-line 4 "Tag0 = hd(Tags),")
                       (indent-line 4 "if")
                       (indent-line 8 "Tag0 /= 0 ->")
                       (indent-line 12 "set_fields(<<Buf/binary, (Tag0 * 2 + 1):16>>, X, Tags, 0);")
                       (indent-line 8 "true ->")
                       (indent-line 12 "set_fields(Buf, X, Tags, -1)")
                       (indent-line 4 "end."))))
            (recr (generate-erlang-set-fields-recursive struct)))
        (string-append spec sign body recr))))

  (define (generate-erlang-set-data-action name field base-indent)
    (let ((fname (>erlang-name (field-name field)))
          (vname (>erlang-var-name (field-name field)))
          (type (field-type field))
          (tag (number->string (field-tag field))))
      (string-append
       (indent-line base-indent tag " ->")
       (if (array-type? type)
           (string-append
            (indent-line (+ base-indent 4) "ObjBin = hd(ObjBins),")
            (indent-line (+ base-indent 4) "Size = size(ObjBin),")
            (indent-line (+ base-indent 4) "set_data(<<Buf/binary, Size:32, ObjBin/binary>>, X, tl(DTags), tl(ObjBins));"))
           (cond
            ((eq? type 'short)
             (string-append
              (indent-line (+ base-indent 4) (generate-erlang-record-match name (list field)) " = X,")
              (indent-line (+ base-indent 4) "set_data(<<Buf/binary, 2:32, " vname ":16>>, X, tl(DTags), ObjBins);")))
            ((eq? type 'int)
             (string-append
              (indent-line (+ base-indent 4) (generate-erlang-record-match name (list field)) " = X,")
              (indent-line (+ base-indent 4) "set_data(<<Buf/binary, 4:32, " vname ":32>>, X, tl(DTags), ObjBins);")))
            ((eq? type 'long)
             (string-append
              (indent-line (+ base-indent 4) (generate-erlang-record-match name (list field)) " = X,")
              (indent-line (+ base-indent 4) "set_data(<<Buf/binary, 8:32, " vname ":64>>, X, tl(DTags), ObjBins);")))
            ((eq? type 'string)
             (string-append
              (indent-line (+ base-indent 4) "StrBin = hd(ObjBins),")
              (indent-line (+ base-indent 4) "Size = size(StrBin),")
              (indent-line (+ base-indent 4) "set_data(<<Buf/binary, Size:32, StrBin/binary>>, X, tl(DTags), tl(ObjBins));")))
            ((custom-type? type)
             (string-append
              (indent-line (+ base-indent 4) "ObjBin = hd(ObjBins),")
              (indent-line (+ base-indent 4) "Size = size(ObjBin),")
              (indent-line (+ base-indent 4) "set_data(<<Buf/binary, Size:32, ObjBin/binary>>, X, tl(DTags), tl(ObjBins));")))
            (else (indent-line (+ base-indent 4) "set_data(Buf, X, tl(DTags), tl(ObjBins));")))))))

  (define (generate-erlang-set-data-recursive struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let* ((spec (indent-line 0 "-spec set_data(binary(), #" name "{}, [non_neg_integer()], [binary()]) -> binary()."))
             (sign "set_data(Buf, X, DTags, ObjBins) ->\n")
             (action (strcat (map (lambda(x) (generate-erlang-set-data-action name x 16)) (filter (lambda (x) (not (eq? 'byte (field-type x)))) fields))))
             (body (string-append
                    (indent-line 04 "Length = length(DTags),")
                    (indent-line 04 "if")
                    (indent-line 08 "Length == 0 ->")
                    (indent-line 12 "Buf;")
                    (indent-line 08 "true ->")
                    (indent-line 12 "Tag = hd(DTags),")
                    (indent-line 12 "case Tag of")
                    (string-append (substring action 0 (- (string-length action) 2)) "\n")
                    (indent-line 12 "end")
                    (indent-line 4 "end."))))
        (string-append spec sign body))))

  (define (generate-erlang-set-data struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((spec (indent-line 0 "-spec set_data(binary(), #" name "{}, #env{}) -> binary()."))
            (sign (indent-line 0 "set_data(Buf, X, #env{dtags = DTags, objbins = ObjBins}) ->"))
            (body (indent-line 4 "set_data(Buf, X, DTags, ObjBins)."))
            (recr (generate-erlang-set-data-recursive struct)))
        (string-append spec sign body recr))))

  (define (generate-erlang-encoder struct)
    (let* ((name (>erlang-name (struct-name struct)))
           (fields (struct-fields struct))
           (none-byte-type-count (length (filter (lambda (x) (not (eq? 'byte (field-type x)))) fields))))
      (let ((object-array-to-binary (generate-erlang-object-array-to-binary struct))
            (analyzer (generate-erlang-analyzer struct))
            (set-fields (generate-erlang-set-fields struct))
            (set-data (if (> none-byte-type-count 0) (generate-erlang-set-data struct) ""))
            (spec (string-append "-spec encode(#" name "{}) -> binary().\n"))
            (sign "encode(X) ->\n")
            (body (string-append
                   (indent-line 4 "Env = analyzer(X),")
                   (indent-line 4 "Count0 = tightrope:adjust_count_for_tag_0(Env),")
                   (indent-line 4 "Count1 = tightrope:adjust_count_for_missed_tags(Env#env{count = Count0}),")
                   (indent-line 4 "NewEnv = Env#env{count = Count1},")
                   (if (> none-byte-type-count 0)
                       (string-append
                        (indent-line 4 "Buf = set_fields(<<Count0:16>>, X, NewEnv),")
                        (indent-line 4 "set_data(Buf, X, NewEnv)."))
                       (indent-line 4 "set_fields(<<Count0:16>>, X, NewEnv).")))))
        (string-append object-array-to-binary analyzer set-fields set-data spec sign body))))

  (define (generate-erlang-encoder-zero-pack struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((spec (string-append "-spec encode0pack(#" name "{}) -> binary().\n"))
            (sign "encode0pack(X) ->\n")
            (body (indent-line 4 "zeropack:pack(encode(X)).")))
        (string-append spec sign body))))
#+end_src

**** 解碼器

解碼器分爲兩個主要步驟：
1. 解析對象原始類型屬性，不包括 String，自定義結構和所有數組，以及超出表達範圍的 short, int, long；
2. 解析數據區的數據，包括 String，自定義結構和所有數組，以及超出表達範圍的 short, int, long。

#+begin_src scheme :exports code :noweb no :tangle /dev/shm/tightrope-build/erlang.scm
  (define (generate-erlang-binary-to-object-array-recursive field)
    (let ((type (>erlang-name (symbol->string (array-base-type (field-type field))))))
      (let ((spec (string-append "-spec binary_to_" type "_array(binary()) -> [#" type "{}].\n"))
            (sign (string-append "binary_to_" type "_array(X) when is_binary(X) ->\n"))
            (body (indent-line 4 "binary_to_" type "_array(X, [])."))
            (spec-recr (string-append "-spec binary_to_" type "_array(binary(), [#"type"{}]) -> [#" type "{}].\n"))
            (sign-recr (string-append "binary_to_" type "_array(X, Acc) when is_binary(X) ->\n"))
            (body-recr (string-append
                        (indent-line 4 "if")
                        (indent-line 8 "size(X) == 0 ->")
                        (indent-line 12 "lists:reverse(Acc);")
                        (indent-line 8 "true ->")
                        (indent-line 12 "<<Size:32, Data:Size/binary, Rest/binary>> = X,")
                        (indent-line 12 (>erlang-var-name type) " = " (>erlang-module-name type) ":decode(Data),")
                        (indent-line 12 "binary_to_" type "_array(Rest, [" (>erlang-var-name type) " | Acc])")
                        (indent-line 4 "end."))))
        (string-append spec sign body spec-recr sign-recr body-recr))))

  (define (generate-erlang-binary-to-object-array struct)
    (let ((fields (filter (lambda (x) (let ((type (field-type x))) (and (array-type? type) (custom-type? (array-base-type type))))) (struct-fields struct))))
      (strcat (map generate-erlang-binary-to-object-array-recursive fields))))

  (define (generate-erlang-parse-fields-action sname field base-indent)
    (let ((vname (>erlang-var-name sname))
          (tag (number->string (field-tag field)))
          (name (>erlang-name (field-name field))))
      (let ((condition (indent-line base-indent "Tag == " tag " ->"))
            (action (indent-line (+ base-indent 4) "parse_fields(Count - 1, Rest, Tag + 1, DTags, " vname "#" (>erlang-module-name sname) "{" name " = V bsr 1 - 1});")))
        (string-append condition action))))

  (define (generate-erlang-parse-fields-recursive sname fields)
    (let ((vname (>erlang-var-name sname)))
      (let ((spec (string-append "-spec parse_fields(non_neg_integer(), binary(), non_neg_integer(), [non_neg_integer()], #" (>erlang-module-name sname) "{}) -> {binary(), [non_neg_integer()], #" (>erlang-module-name sname) "{}}.\n"))
            (sign (string-append "parse_fields(Count, Buffer, Tag, DTags, " vname ") ->\n"))
            (body (string-append
                   (indent-line 4 "if")
                   (indent-line 8 "Count == 0 ->")
                   (indent-line 12 "{Buffer, lists:reverse(DTags), " vname "};")
                   (indent-line 8 "true ->")
                   (indent-line 12 "<<V:16, Rest/binary>> = Buffer,")
                   (indent-line 12 "if")
                   (indent-line 16 "V band 1 == 1 ->")
                   (indent-line 20 "parse_fields(Count - 1, Rest, Tag + ((V - 1) bsr 1), DTags, " vname ");")
                   (indent-line 16 "V == 0 ->")
                   (indent-line 20 "parse_fields(Count - 1, Rest, Tag + 1, [Tag | DTags], " vname ");")
                   (strcat (map (lambda (x) (generate-erlang-parse-fields-action sname x 16)) (filter (lambda (x) (let ((type (field-type x))) (not (or (eq? type 'string) (custom-type? type) (array-type? type))))) fields)))
                   (indent-line 16 "true ->")
                   (indent-line 20 "parse_fields(Count - 1, Rest, Tag + 1, DTags, " vname ")")
                   (indent-line 12 "end")
                   (indent-line 4 "end."))))
        (string-append spec sign body))))

  (define (generate-erlang-parse-fields struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((spec (string-append "-spec parse_fields(binary()) -> {binary(), [non_neg_integer()], #" (>erlang-module-name name) "{}}.\n"))
            (sign "parse_fields(X) ->\n")
            (body (string-append
                   (indent-line 4 "<<Count:16, Rest/binary>> = X,")
                   (indent-line 4 "parse_fields(Count, Rest, 0, [], #" (>erlang-module-name name) "{}).")))
            (recur (generate-erlang-parse-fields-recursive name fields)))
        (string-append spec sign body recur))))

  (define (generate-erlang-parse-data-action sname field base-indent)
    (let ((tag (number->string (field-tag field)))
          (name (>erlang-name (field-name field)))
          (type (field-type field)))
      (string-append
       (indent-line base-indent tag " ->")
       (indent-line (+ base-indent 4) "<<Length:32, Data:Length/binary, Rest/binary>> = Buffer,")
       (if (array-type? type)
           (let ((base-type (array-base-type type)))
             (cond
              ((custom-type? base-type)
               (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = binary_to_" (>erlang-module-name (symbol->string base-type)) "_array(Data)});"))
              ((eq? base-type 'string)
               (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = tightrope:binary_to_string_array(Data)});"))
              ((eq? base-type 'byte)
               (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = tightrope:binary_to_number_array(Data, ?BYTE_SIZE)});"))
              ((eq? base-type 'short)
               (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = tightrope:binary_to_number_array(Data, ?SHORT_SIZE)});"))
              ((eq? base-type 'int)
               (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = tightrope:binary_to_number_array(Data, ?INT_SIZE)});"))
              ((eq? base-type 'long)
               (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = tightrope:binary_to_number_array(Data, ?LONG_SIZE)});"))))
           (cond
            ((custom-type? type)
             (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = " (>erlang-module-name (symbol->string type)) ":decode(Data)});"))
            ((eq? type 'string)
             (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = unicode:characters_to_list(Data)});"))
            ((eq? type 'short)
             (string-append
              (indent-line (+ base-indent 4) "<<Num:?SHORT_SIZE/integer-signed>> = Data,")
              (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = Num});")))
            ((eq? type 'int)
             (string-append
              (indent-line (+ base-indent 4) "<<Num:?INT_SIZE/integer-signed>> = Data,")
              (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = Num});")))
            ((eq? type 'long)
             (string-append
              (indent-line (+ base-indent 4) "<<Num:?LONG_SIZE/integer-signed>> = Data,")
              (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "#" (>erlang-module-name sname) "{" name " = Num});")))
            (else
             (indent-line (+ base-indent 4) "parse_data(Rest, tl(DTags), " (>erlang-var-name sname) "});")))))))

  (define (generate-erlang-parse-data struct)
    (let* ((name (>erlang-name (struct-name struct)))
           (fields (struct-fields struct))
           (vname (>erlang-var-name name))
           (action (strcat (map (lambda (x) (generate-erlang-parse-data-action name x 16)) (filter (lambda (x) (not (eq? (field-type x) 'byte))) fields)))))
      (let ((spec (string-append "-spec parse_data(binary(), [non_neg_integer()], #" (>erlang-module-name name) "{}) -> #" (>erlang-module-name name) "{}.\n"))
            (sign (string-append "parse_data(Buffer, DTags, " vname ") ->\n"))
            (body (string-append
                   (indent-line 4 "if")
                   (indent-line 8 "length(DTags) == 0 ->")
                   (indent-line 12 vname ";")
                   (indent-line 8 "true ->")
                   (indent-line 12 "Tag = hd(DTags),")
                   (indent-line 12 "case Tag of")
                   (string-append (substring action 0 (- (string-length action) 2)) "\n")
                   (indent-line 12 "end")
                   (indent-line 4 "end."))))
        (string-append spec sign body))))

  (define (generate-erlang-decoder struct)
    (let* ((name (>erlang-name (struct-name struct)))
           (fields (struct-fields struct))
           (none-byte-type-count (length (filter (lambda (x) (not (eq? 'byte (field-type x)))) fields))))
      (let ((binary-to-object-array (generate-erlang-binary-to-object-array struct))
            (parse-fields (generate-erlang-parse-fields struct))
            (parse-data (if (> none-byte-type-count 0) (generate-erlang-parse-data struct) ""))
            (spec (string-append "-spec decode(binary()) -> #" name "{}.\n"))
            (sign "decode(X) when is_binary(X) ->\n")
            (body (if (> none-byte-type-count 0)
                      (string-append
                       (indent-line 4 "{Rest, DTags, " (>erlang-var-name name) " } = parse_fields(X),")
                       (indent-line 4 "parse_data(Rest, DTags, " (>erlang-var-name name) ")."))
                      (string-append
                       (indent-line 4 "{_, _, " (>erlang-var-name name) " } = parse_fields(X),")
                       (indent-line 4 (>erlang-var-name name) ".")))))
        (string-append binary-to-object-array parse-fields parse-data spec sign body))))

  (define (generate-erlang-decoder-zero-pack struct)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((spec (string-append "-spec decode0pack(binary()) -> #" name "{}.\n"))
            (sign "decode0pack(X) when is_binary(X) ->\n")
            (body (indent-line 4 "decode(zeropack:unpack(X)).")))
        (string-append spec sign body))))
#+end_src

**** 主體

序列化和反序列化的代碼都放置在對應的 erl 文件中。一些運行時的輔助函數放置在
tightrope.erl 和 tightrope.hrl 文件中。

#+begin_src scheme :exports code :noweb no :tangle /dev/shm/tightrope-build/erlang.scm
  (define (generate-erlang-tightrope-runtime dir)
    (with-output-to-file
        (string-append dir "tightrope.hrl")
      (lambda ()
        (write-string "-record(env, {count :: non_neg_integer(), tags :: [non_neg_integer()], dtags :: [non_neg_integer()], objbins :: [binary()]}).

  -define(BYTE_SIZE, 8).

  -define(SHORT_SIZE, 16).

  -define(INT_SIZE, 32).

  -define(LONG_SIZE, 64)."))
      (list 'replace))
    (with-output-to-file
        (string-append dir "tightrope.erl")
      (lambda ()
        (write-string "-module(tightrope).

  -export([adjust_count_for_tag_0/1, adjust_count_for_missed_tags/1, number_array_to_binary/2, binary_to_number_array/2, string_array_to_binary/1, binary_to_string_array/1]).

  -include(\"tightrope.hrl\").

  -spec adjust_count_for_tag_0(#env{}) -> non_neg_integer().

  adjust_count_for_tag_0(#env{count = Count, tags = Tags}) ->
      if
          Count /= 0, hd(Tags) /= 0 ->
              Count + 1;
          true ->
              Count
      end.

  -spec adjust_count_for_missed_tags(#env{}) -> non_neg_integer().

  adjust_count_for_missed_tags(#env{count = Count, tags = Tags}) ->
      if length(Tags) == 1 ->
              Count;
         true ->
              adjust_count_for_missed_tags(length(Tags), Tags, Count)
      end.

  -spec adjust_count_for_missed_tags(non_neg_integer(), [non_neg_integer()], non_neg_integer()) -> non_neg_integer().

  adjust_count_for_missed_tags(Idx, Tags, Count) ->
      if
          Idx == 1 ->
              Count;
          true ->
              PreTag = lists:nth(Idx - 1, Tags),
              NextTag = lists:nth(Idx, Tags),
              if
                  PreTag + 1 =/= NextTag ->
                      adjust_count_for_missed_tags(Idx - 1, Tags, Count + 1);
                  true ->
                      adjust_count_for_missed_tags(Idx - 1, Tags, Count)
              end
      end.

  -spec number_array_to_binary([integer()], non_neg_integer()) -> binary().

  number_array_to_binary(X, Size) ->
      number_array_to_binary(X, Size, <<>>).

  -spec number_array_to_binary([integer()], non_neg_integer(), binary()) -> binary().

  number_array_to_binary(X, Size, Acc) ->
      if
          length(X) == 0 ->
              Length = size(Acc),
              <<Length:32, Acc/binary>>;
          true ->
              Y = hd(X),
              number_array_to_binary(tl(X), Size, <<Acc/binary, Y:Size/integer-signed>>)
      end.

  -spec binary_to_number_array(binary(), non_neg_integer()) -> [integer()].

  binary_to_number_array(X, Size) when is_binary(X) ->
      binary_to_number_array(X, Size, []).

  -spec binary_to_number_array(binary(), non_neg_integer(), [integer()]) -> [integer()].

  binary_to_number_array(X, Size, Acc) when is_binary(X) ->
      if
          size(X) == 0 ->
              lists:reverse(Acc);
          true ->
              <<Data:Size/integer-signed, Rest/binary>> = X,
              binary_to_number_array(Rest, Size, [Data | Acc])
      end.

  -spec string_array_to_binary([string()]) -> binary().

  string_array_to_binary(X) ->
      string_array_to_binary(X, <<>>).

  -spec string_array_to_binary([string()], binary()) -> binary().

  string_array_to_binary(X, Acc) ->
      if
          length(X) == 0 ->
              Size = size(Acc),
              <<Size:32, Acc/binary>>;
          true ->
              Y = unicode:characters_to_binary(hd(X)),
              Size = size(Y),
              string_array_to_binary(tl(X), <<Acc/binary, Size:32, Y/binary>>)
      end.

  -spec binary_to_string_array(binary()) -> [string()].

  binary_to_string_array(X) when is_binary(X) ->
      binary_to_string_array(X, []).

  -spec binary_to_string_array(binary(), [string()]) -> [string()].

  binary_to_string_array(X, Acc) when is_binary(X) ->
      if
          size(X) == 0 ->
              lists:reverse(Acc);
          true ->
              <<Size:32, Str:Size/binary, Rest/binary>> = X,
              binary_to_string_array(Rest, [unicode:characters_to_list(Str) | Acc])
      end."))
      (list 'replace)))

  (define (generate-erlang-serial env struct dir)
    (let ((name (>erlang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((module-declare (string-append "-module(" (>erlang-module-name name) ").\n"))
            (export "-export([encode/1, encode0pack/1, decode/1, decode0pack/1]).\n")
            (includes (string-append "-include(\"tightrope.hrl\").\n" "-include(\"" name ".hrl\").\n"))
            (encode-function (generate-erlang-encoder struct))
            (encode-zero-pack-function (generate-erlang-encoder-zero-pack struct))
            (decode-function (generate-erlang-decoder struct))
            (decode-zero-pack-function (generate-erlang-decoder-zero-pack struct)))
        (with-output-to-file
            (string-append dir (>erlang-module-name name) ".erl")
          (lambda ()
            (write-string (string-append module-declare export includes encode-function encode-zero-pack-function decode-function decode-zero-pack-function)))
          (list 'replace)))))

  (define (generate-erlang-serials env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (generate-erlang-tightrope-runtime path)
      (generate-erlang-zero-pack env dir)
      (for-each
       (lambda (entity) (generate-erlang-serial env entity path))
       (get-structs env))))
#+end_src

*** 壓縮和解壓
Tightrope 會在生成壓縮和解壓的 Erlang 代碼。
#+begin_src scheme :exports code :tangle /dev/shm/tightrope-build/erlang.scm
  (define (generate-erlang-zero-pack env dir)
    (let ((path dir)
          (src "-module(zeropack).

  -export([pack/1, unpack/1]).

  -spec pack(binary()) -> binary().

  pack(X) when is_binary(X) ->
      Size = size(X),
      Rem = Size rem 8,
      Tmp = if
                Rem /= 0 ->
                    R = Size rem 8,
                    Padding = binary:copy(<<0>>, 8 - R),
                    pack(<<X/binary, Padding/binary>>, <<>>, 0, <<>>, 0);
                true ->
                    pack(X, <<>>, 0, <<>>, 0)
            end,
      TmpSize = size(Tmp),
      if
          Size rem TmpSize > 0 ->
              <<((Size div TmpSize) + 1):8, Tmp/binary>>;
          true ->
              <<(Size div TmpSize):8, Tmp/binary>>
      end.

  -spec pack(binary(), binary(), non_neg_integer(), binary(), non_neg_integer()) -> binary().

  pack(Src, Dst, FFCnt, FFBuf, OOCnt) ->
      if
          size(Src) == 0 ->
              if
                  FFCnt > 0 ->
                      <<Dst/binary, 16#FF, FFCnt:8, FFBuf/binary>>;
                  OOCnt > 0 ->
                      <<Dst/binary, 0, OOCnt:8>>;
                  true ->
                      Dst
              end;
          true ->
              <<Group:8/binary, Rest/binary>> = Src,
              Bitmap = calc_bitmap(Group),
              case Bitmap of
                  0 ->
                      Tmp = if
                                FFCnt > 0 ->
                                    <<16#FF:8, FFCnt:8, FFBuf/binary>>;
                                true ->
                                    <<>>
                            end,
                      if
                          OOCnt == 0 ->
                              pack(Rest, <<Dst/binary, Tmp/binary>>, 0, <<>>, 1);
                          OOCnt == 16#FF ->
                              pack(Rest, <<Dst/binary, Tmp/binary, 0, OOCnt:8>>, 0, <<>>, 1);
                          true ->
                              pack(Rest, <<Dst/binary, Tmp/binary>>, 0, <<>>, OOCnt + 1)
                      end;
                  16#FF ->
                      Tmp = if
                                OOCnt > 0 ->
                                    <<0, OOCnt:8>>;
                                true ->
                                    <<>>
                            end,
                      if
                          FFCnt == 0 ->
                              pack(Rest, <<Dst/binary, Tmp/binary>>, 1, <<Group/binary>>, 0);
                          FFCnt == 16#FF ->
                              pack(Rest, <<Dst/binary, Tmp/binary, 16#FF, FFCnt:8, FFBuf/binary>>, 1, <<Group/binary>>, 0);
                          true ->
                              pack(Rest, <<Dst/binary, Tmp/binary>>, FFCnt + 1, <<FFBuf/binary, Group/binary>>, 0)
                      end;
                  _ ->
                      Zipped = zip(Group),
                      if
                          FFCnt > 0 ->
                              pack(Rest, <<Dst/binary, 16#FF, FFCnt:8, FFBuf/binary, Bitmap:8, Zipped/binary>>, 0, <<>>, OOCnt);
                          OOCnt > 0 ->
                              pack(Rest, <<Dst/binary, 0, OOCnt:8, Bitmap:8, Zipped/binary>>, FFCnt, FFBuf, 0);
                          true ->
                              pack(Rest, <<Dst/binary, Bitmap:8, Zipped/binary>>, FFCnt, FFBuf, OOCnt)
                      end
              end
      end.

  -spec calc_bitmap(binary()) -> non_neg_integer().

  calc_bitmap(X) ->
      calc_bitmap(binary_to_list(X), 0).

  -spec calc_bitmap([byte()], non_neg_integer()) -> non_neg_integer().

  calc_bitmap(X, Bitmap) ->
      Length = length(X),
      if
          Length == 0 ->
              Bitmap;
          true ->
              if
                  hd(X) /= 0 ->
                      calc_bitmap(tl(X), Bitmap bor (1 bsl (Length - 1)));
                  true ->
                      calc_bitmap(tl(X), Bitmap)
              end
      end.

  -spec zip(binary()) -> binary().

  zip(X) ->
      zip(binary_to_list(X), <<>>).

  -spec zip([byte()], binary()) -> binary().

  zip(X, Acc) ->
      if
          length(X) == 0 ->
              Acc;
          true ->
              Head = hd(X),
              if
                  Head == 0 ->
                      zip(tl(X), Acc);
                  true ->
                      zip(tl(X), <<Acc/binary, Head:8>>)
              end
      end.

  -spec unpack(binary()) -> binary().

  unpack(X) when is_binary(X) ->
      <<_:8, Buffer/binary>> = X,
      unpack(Buffer, <<>>).

  -spec unpack(binary(), binary()) -> binary().

  unpack(Src, Dst) ->
      if
          size(Src) == 0 ->
              Dst;
          true ->
              <<Head:8, Rest/binary>> = Src,
              case Head of
                  0 ->
                      <<Cnt:8, R/binary>> = Rest,
                      Padding = binary:copy(<<0,0,0,0,0,0,0,0>>, Cnt),
                      unpack(R, <<Dst/binary, Padding/binary>>);
                  16#FF ->
                      <<Cnt:8, RR/binary>> = Rest,
                      Length = Cnt * 8,
                      <<Data:Length/binary, R/binary>> = RR,
                      unpack(R, <<Dst/binary, Data/binary>>);
                  _ ->
                      Cnt = calc_bitmap_count(Head),
                      <<Data:Cnt/binary, R/binary>> = Rest,
                      Expanded = expand_bitmap(Head, Data),
                      unpack(R, <<Dst/binary, Expanded/binary>>)
              end
      end.

  -spec calc_bitmap_count(byte()) -> non_neg_integer().

  calc_bitmap_count(X) ->
      calc_bitmap_count(X, 8, 0).

  -spec calc_bitmap_count(byte(), non_neg_integer(), non_neg_integer()) -> non_neg_integer().

  calc_bitmap_count(X, Loop, Acc) ->
      if
          Loop == 0 ->
              Acc;
          true ->
              if
                  X band (1 bsl (Loop - 1)) > 0 ->
                      calc_bitmap_count(X, Loop - 1, Acc + 1);
                  true ->
                      calc_bitmap_count(X, Loop - 1, Acc)
              end
      end.

  -spec expand_bitmap(byte(), binary()) -> binary().

  expand_bitmap(X, Data) ->
      expand_bitmap(X, binary_to_list(Data), 8, <<>>).

  -spec expand_bitmap(byte(), [byte()], non_neg_integer(), binary()) -> binary().

  expand_bitmap(X, Data, Loop, Dest) ->
      if
          Loop == 0 ->
              Dest;
          true ->
              if
                  X band (1 bsl (Loop - 1)) > 0 ->
                      Byte = hd(Data),
                      expand_bitmap(X, tl(Data), Loop - 1, <<Dest/binary, Byte:8>>);
                  true ->
                      expand_bitmap(X, Data, Loop - 1, <<Dest/binary, 0>>)
              end
      end.
  "))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (with-output-to-file
          (string-append path "zeropack.erl")
        (lambda ()
          (write-string src))
        (list 'replace))))
#+end_src
*** 輔助函數
#+begin_src scheme :noweb-ref utility
  (define (>erlang-name name)
    (let loop ((src (map char-downcase (string->list name)))
               (dst '()))
      (if (null? src)
          (list->string (reverse dst))
          (let ((chr (car src))
                (rest (cdr src)))
            (if (eq? chr #\-)
                (loop rest (cons #\_ dst))
                (loop rest (cons chr dst)))))))

  (define (>erlang-module-name name)
    (>erlang-name name))

  (define (>erlang-var-name name)
    (let ((l (string->list (>erlang-name name))))
      (list->string (cons (char-upcase (car l)) (cdr l)))))

  (define (>erlang-type type)
    (case type
      ((byte) "byte()")
      ((short) "integer()")
      ((int) "integer()")
      ((long) "integer()")
      ((string) "string()")
      (else "integer()")))

  (define (generate-erlang-record-accessor sname fname)
    (string-append (>erlang-var-name sname) "#" (>erlang-name sname) "." (>erlang-name fname)))
#+end_src
