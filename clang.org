* c 後端實現

正在進行中。
** 實體對象
在 Tightrope C 實現中，用結構體來實現數據結構，實體對象的名稱遵循 C 語言的命名規
則，以 "_t" 結尾。實體對象的定義保存在對應的頭文件中，方便各個模塊調用。

#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  <<utility>>

  (define (generate-clang-include field)
    (if (custom-type? (field-type field))
        (string-append "#include \"" (>clang-name (symbol->string (field-type field))) ".h\"\n")
        ""))

  (define (generate-clang-field-declare field)
    (let ((name (>clang-name (field-name field)))
          (type (field-type field)))
      (if (array-type? type)
          (let ((base-type (array-base-type type)))
            (string-append (>clang-type base-type) (if (custom-type? base-type) " *" " ") "* " name ";\n    int __" name "_len;"))
          (string-append (>clang-type type) (if (custom-type? type) " * " " ") name ";"))))

  (define (generate-clang-field-setter-declare struct-name field indent)
    (let ((name (>clang-name (field-name field)))
          (type (field-type field)))
      (if (array-type? type)
          (let ((base-type (array-base-type type)))
            (string-append
             (indent-line indent "inline void " struct-name "_set_" name "(" (>clang-struct-name struct-name) " * " struct-name ", " (>clang-type base-type) (if (custom-type? base-type) " ** " " * ") name ", int len) {")
             (indent-line (+ indent 2) struct-name "->" name " = " name ";")
             (indent-line (+ indent 2) struct-name "->__" name "_len = len;")
             (indent-line indent "}")))
          "")))

  (define (generate-clang-entity struct dir)
    (let ((name (>clang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((macro-name (>clang-macro-name (string-append "_" name "_h")))
            (includes (strcat (map generate-clang-include fields)))
            (sname (>clang-struct-name name))
            (field-decls (strcat (map (lambda (x) (indent-line 4 (generate-clang-field-declare x))) fields)))
            (setters (strcat (map (lambda (x) (generate-clang-field-setter-declare name x 2)) (filter (lambda (y) (array-type? (field-type y))) fields)))))
        (let ((content
               (string-append
                (indent-line 0 "#ifndef " macro-name)
                (indent-line 0 "#define " macro-name)
                (indent-line 0 "#include <stdint.h>")
                includes
                (indent-line 0 "#ifdef __cplusplus")
                (indent-line 0 "extern \"C\" {")
                (indent-line 0 "#endif")
                (indent-line 2 "typedef struct " name " " sname ";")
                (indent-line 2 "struct " name " {")
                field-decls
                (indent-line 2 "};")
                (indent-line 2 "int " name "_calculate_size(" sname " *);")
                (indent-line 2 "void " name "_encode(" sname " *, unsigned char *);")
                (indent-line 2 "int " name "_estimate_size(unsigned char *);")
                (indent-line 2 "void " name "_decode(unsigned char *, " sname " *);")
                setters
                (indent-line 0 "#ifdef __cplusplus")
                (indent-line 0 "}")
                (indent-line 0 "#endif")
                (indent-line 0 "#endif"))))
          (with-output-to-file
              (string-append dir name ".h")
            (lambda ()
              (write-string content))
            (list 'replace))))))

  (define (generate-clang-entities env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (for-each
       (lambda (entity) (generate-clang-entity entity path))
       (get-structs env))))
#+end_src

** 壓縮與解壓
Tightrope 把壓縮和解壓的代碼放到獨立的文件中，供使用者調用。

#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  (define (generate-clang-zero-pack-header path)
    (let ((src "#ifndef _ZEROPACK_H
  #define _ZEROPACK_H
  #ifdef __cplusplus
  extern \"C\" {
  #endif
    int zeropack(unsigned char * src, int len, unsigned char * dst);
    int zerounpack(unsigned char * src, int len, unsigned char * dst);
  #ifdef __cplusplus
  }
  #endif
  #"))
      (with-output-to-file
          (string-append path "zeropack.h")
        (lambda ()
          (write-string src))
        (list 'replace))))

  (define (generate-clang-zero-pack-source path)
    (let ((src "#include <string.h>
  #include \"zeropack.h\"

  int zeropack(unsigned char * src, int len, unsigned char * dst) {
    unsigned char ffcnt = 0;
    int ffpos = 0;
    unsigned char oocnt = 0;
    int oopos = 0;
    int ptr = 1;
    unsigned char bytes[0];
    int bptr = 0;
    unsigned char bitmap = 0;
    int blen = len + ((len % 8) != 0 ? (8 - len % 8): 0);
    unsigned char buf[blen];
    memset(buf, 0, blen);
    memcpy(buf, src, len);
    for (int i = 0, l = blen / 8; i < l; i ++) {
      bptr = 0;
      bitmap = 0;
      for (int j = 0; j < 8; j ++) {
        if (buf[i * 8 + j] != 0) {
          bitmap = bitmap | (1 << (8 - j - 1));
          bytes[bptr ++] = buf[i * 8 + j];
        }
      }
      if (bitmap == 0x00) {
        if (ffcnt > 0) {
          dst[ffpos] = ffcnt;
          ffcnt = 0;
        }
        if (oocnt == 0) {
          dst[ptr ++] = 0x00;
          oopos = ptr ++;
          oocnt ++;
        } else if (oocnt == 0xFF) {
          dst[oopos] = 0xFF;
          dst[ptr ++] = 0x00;
          oopos = ptr ++;
          oocnt = 1;
        } else {
          oocnt ++;
        }
      } else if (bitmap == 0xFF) {
        if (oocnt > 0) {
          dst[oopos] = oocnt;
          oocnt = 0;
        }
        if (ffcnt == 0) {
          dst[ptr ++] = 0xFF;
          ffpos = ptr ++;
          ffcnt ++;
        } else if (ffcnt == 0xFF) {
          dst[ffpos] = 0xFF;
          dst[ptr ++] = 0xFF;
          ffpos = ptr ++;
          ffcnt = 1;
        } else {
          ffcnt ++;
        }
        for (int k = 0; k < bptr; k ++) {
          dst[ptr ++] = bytes[k];
        }
      } else {
        dst[ptr ++] = bitmap;
        if (oocnt > 0) {
          dst[oopos] = oocnt;
          oocnt = 0;
        } else if (ffcnt > 0) {
          dst[ffpos] = ffcnt;
          ffcnt = 0;
        }
        for (int k = 0; k < bptr; k ++) {
          dst[ptr ++] = bytes[k];
        }
      }
    }
    if (oocnt > 0) {
      dst[oopos] = oocnt;
    } else if (ffcnt > 0) {
      dst[ffpos] = ffcnt;
    }

    dst[0] = blen / ptr + (blen % ptr != 0? 1 : 0);

    return ptr;
  }

  int zerounpack(unsigned char * src, int len, unsigned char * dst) {
    int sptr = 1;
    int dptr = 0;
    int cnt = 0;
    while (sptr < len) {
      switch (src[sptr]) {
      case 0:
        cnt = src[sptr + 1];
        for (int i = 0; i < cnt; i ++) {
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
        }
        sptr += 2;
        break;
      case 0xFF:
        cnt = src[sptr + 1];
        memcpy(dst + dptr, src + sptr + 2, cnt * 8);
        dptr += cnt * 8;
        sptr += 2 + cnt * 8;
        break;
      default:
        cnt = 0;
        for (int i = 0; i < 8; i ++) {
          if ((src[sptr] & (1 << (8 - i - 1))) > 0) {
            cnt ++;
            dst[dptr ++] = src[sptr + cnt];
          } else {
            dst[dptr ++] = 0;
          }
        }
        sptr += cnt + 1;
        break;
      }
    }
    return dptr;
  }
  "))
      (with-output-to-file
          (string-append path "zeropack.c")
        (lambda ()
          (write-string src))
        (list 'replace))))

  (define (generate-clang-zero-pack env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (generate-clang-zero-pack-header path)
      (generate-clang-zero-pack-source path)))
#+end_src

** 序列化與反序列化
*** 計算編碼大小
#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  (define (generate-clang-calculate-size-recursive sname field indent)
    (let ((type (field-type field))
          (name (>clang-name (field-name field))))
      (let ((accessor (>clang-accessor sname name))
            (len-accessor (>clang-accessor sname (string-append "__" name "_len"))))
        (if (array-type? type)
            (let ((base-type (array-base-type type)))
              (cond
               ((primitive-type? base-type)
                (string-append
                 (indent-line indent "if (" accessor " != NULL) {")
                 (indent-line (+ indent 2) "size += 2 + 4 + " len-accessor " * " (case base-type ((short) "2") ((int) "4") ((long) "8") (else "1")) ";")
                 (indent-line indent "}")))
               ((eq? base-type 'string)
                (string-append
                 (indent-line indent "if (" accessor " != NULL) {")
                 (indent-line (+ indent 2) "size += 2 + 4 + 4;")
                 (indent-line (+ indent 2) "for (int i = 0; i < " len-accessor "; i ++) {")
                 (indent-line (+ indent 4) "size += 4 + strlen(" accessor "[i]);")
                 (indent-line (+ indent 2) "}")
                 (indent-line indent "}")))
               (else
                (string-append
                 (indent-line indent "if (" accessor " != NULL) {")
                 (indent-line (+ indent 2) "size += 2 + 4 + 4;")
                 (indent-line (+ indent 2) "for (int i = 0; i < " len-accessor "; i ++) {")
                 (indent-line (+ indent 4) "size += 4 + " (>clang-name (symbol->string base-type)) "_calculate_size(" accessor "[i]);")
                 (indent-line (+ indent 2) "}")
                 (indent-line indent "}")))))
            (cond
             ((primitive-type? type)
              (string-append
               (indent-line indent "if (" accessor " != 0) {")
               (string-append
                (indent-line (+ indent 2) "if (" accessor " > 0 && " accessor " < 16383) {")
                (indent-line (+ indent 4) "size += 2;")
                (indent-line (+ indent 2) "} else {")
                (indent-line (+ indent 4) "size += 2 + 4 + " (case type ((byte) "1") ((short) "2") ((int) "4") ((long) "8") (else "0")) ";")
                (indent-line (+ indent 2) "}"))
               (indent-line indent "}")))
             ((eq? type 'string)
              (string-append
               (indent-line indent "if (" accessor " != NULL) {")
               (indent-line (+ indent 2) "size += 2 + 4 + strlen(" accessor ");")
               (indent-line indent "}")))
             (else
              (string-append
               (indent-line indent "if (" accessor " != NULL) {")
               (indent-line (+ indent 2) "size += 2 + 4 + " (>clang-name (symbol->string type)) "_calculate_size(" accessor ");")
               (indent-line indent "}"))))))))

  (define (generate-clang-calculate-size sname fields)
    (string-append
     (indent-line 0 "int " sname "_calculate_size(" (>clang-struct-name sname) " * " sname ") {")
     (indent-line 2 "int size = 2;")
     (strcat (map (lambda (x) (generate-clang-calculate-size-recursive sname x 2)) fields))
     (indent-line 0 "}")))
#+end_src
*** 編碼器
#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  (define (generate-clang-set-field-action sname field indent)
    (let ((type (field-type field))
          (tag (number->string (field-tag field)))
          (name (>clang-name (field-name field))))
      (let ((accessor (>clang-accessor sname name)))
        (string-append
         (indent-line indent "case " tag ":")
         (if (primitive-type? type)
             (string-append
              (indent-line (+ indent 2) "if (" accessor " != 0) {")
              (indent-line (+ indent 4) "count ++;")
              (indent-line (+ indent 4) "ptr += tightrope_padding(tag, nexttag, buf + ptr, &count);")
              (if (eq? type 'byte)
                  (string-append
                   (indent-line (+ indent 4) "short t = (short) ((" accessor " + 1) * 2);")
                   (indent-line (+ indent 4) "buf[ptr ++] = SHORT0(t);")
                   (indent-line (+ indent 4) "buf[ptr ++] = SHORT1(t);"))
                  (string-append
                   (indent-line (+ indent 4) "if (" accessor " > 0 && " accessor " < 16383) {")
                   (indent-line (+ indent 6) "short t = (short) ((" accessor " + 1) * 2);")
                   (indent-line (+ indent 6) "buf[ptr ++] = SHORT0(t);")
                   (indent-line (+ indent 6) "buf[ptr ++] = SHORT1(t);")
                   (indent-line (+ indent 4) "} else {")
                   (indent-line (+ indent 6) "buf[ptr ++] = 0;")
                   (indent-line (+ indent 6) "buf[ptr ++] = 0;")
                   (indent-line (+ indent 4) "}")))
              (indent-line (+ indent 4) "tag = nexttag + 1;")
              (indent-line (+ indent 2) "}"))
             (string-append
              (indent-line (+ indent 2) "if (" accessor " != NULL) {")
              (indent-line (+ indent 4) "dtags[* dlen] = " tag ";")
              (indent-line (+ indent 4) "(* dlen) ++;")
              (indent-line (+ indent 4) "count ++;")
              (indent-line (+ indent 4) "ptr += tightrope_padding(tag, nexttag, buf + ptr, &count);")
              (indent-line (+ indent 4) "buf[ptr ++] = 0;")
              (indent-line (+ indent 4) "buf[ptr ++] = 0;")
              (indent-line (+ indent 4) "tag = nexttag + 1;")
              (indent-line (+ indent 2) "}")))
         (indent-line indent "break;")))))

  (define (generate-clang-set-fields sname fields)
    (let ((max-tag (number->string (apply max (map (lambda(x) (field-tag x)) fields)))))
      (string-append
       (indent-line 0 "static int " sname "_set__fields(" (>clang-struct-name sname) " * " sname ", unsigned char * buf, short * dtags, int * dlen) {")
       (indent-line 2 "int ptr = 2;")
       (indent-line 2 "short count = 0;")
       (indent-line 2 "for (short tag = 0, nexttag = 0; nexttag < " max-tag "; nexttag ++) {")
       (indent-line 4 "switch (nexttag) {")
       (strcat (map (lambda (x) (generate-clang-set-field-action sname x 4)) fields))
       (indent-line 4 "default:")
       (indent-line 6 "break;")
       (indent-line 4 "}")
       (indent-line 2 "}")
       (indent-line 2 "buf[0] = SHORT0(count);")
       (indent-line 2 "buf[0] = SHORT1(count);")
       (indent-line 2 "return ptr;")
       (indent-line 0 "}"))))

  (define (generate-clang-set-data-action sname field indent)
    (let ((tag (number->string (field-tag field)))
          (type (field-type field))
          (name (>clang-name (field-name field))))
      (let ((accessor (>clang-accessor sname name))
            (len-accessor (>clang-accessor sname (string-append "__" name "_len"))))
        (string-append
         (indent-line indent "case " tag ": {")
         (if (array-type? type)
             (let ((base-type (array-base-type type)))
               (case base-type
                 ((byte)
                  (string-append
                   (indent-line (+ indent 2) "size = " len-accessor ";")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "buf[ptr ++] = " accessor "[j];")
                   (indent-line (+ indent 2) "}")))
                 ((short)
                  (string-append
                   (indent-line (+ indent 2) "size = " len-accessor " * 2;")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "buf[ptr ++] = SHORT0(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = SHORT1(" accessor "[j]);")
                   (indent-line (+ indent 2) "}")))
                 ((int)
                  (string-append
                   (indent-line (+ indent 2) "size = " len-accessor " * 4;")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT0(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT1(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT2(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT3(" accessor "[j]);")
                   (indent-line (+ indent 2) "}")))
                 ((long)
                  (string-append
                   (indent-line (+ indent 2) "size = " len-accessor " * 8;")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG0(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG1(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG2(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG3(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG4(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG5(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG6(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = LONG7(" accessor "[j]);")
                   (indent-line (+ indent 2) "}")))
                 ((string)
                  (string-append
                   (indent-line (+ indent 2) "size = 0;")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "size += strlen(" accessor "[j]);")
                   (indent-line (+ indent 2) "}")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "int len = strlen(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT0(len);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT1(len);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT2(len);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT3(len);")
                   (indent-line (+ indent 4) "memcpy(buf + ptr, " accessor "[j], len);")
                   (indent-line (+ indent 4) "ptr += len;")
                   (indent-line (+ indent 2) "}")))
                 (else
                  (string-append
                   (indent-line (+ indent 2) "size = 0;")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "size += " (>clang-name (symbol->string base-type)) "_calculate_size(" accessor "[j]);")
                   (indent-line (+ indent 2) "}")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                   (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                   (indent-line (+ indent 2) "for (int j = 0; j < " len-accessor "; j ++) {")
                   (indent-line (+ indent 4) "int len = " (>clang-name (symbol->string base-type)) "_calculate_size(" accessor "[j]);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT0(len);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT1(len);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT2(len);")
                   (indent-line (+ indent 4) "buf[ptr ++] = INT3(len);")
                   (indent-line (+ indent 4) (>clang-name (symbol->string base-type)) "_encode(" accessor "[j], buf + ptr);")
                   (indent-line (+ indent 4) "ptr += len;")
                   (indent-line (+ indent 2) "}")))))
             (case type
               ((byte)
                (string-append
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 1;")
                 (indent-line (+ indent 2) "buf[ptr ++] = " accessor ";")))
               ((short)
                (string-append
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 2;")
                 (indent-line (+ indent 2) "buf[ptr ++] = SHORT0(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = SHORT1(" accessor ");")))
               ((int)
                (string-append
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 4;")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT0(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT1(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT2(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT3(" accessor ");")))
               ((long)
                (string-append
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 0;")
                 (indent-line (+ indent 2) "buf[ptr ++] = 8;")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG0(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG1(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG2(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG3(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG4(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG5(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG6(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = LONG7(" accessor ");")))
               ((string)
                (string-append
                 (indent-line (+ indent 2) "size = strlen(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                 (indent-line (+ indent 2) "memcpy(buf + ptr, " accessor ", size);")
                 (indent-line (+ indent 2) "ptr += size;")))
               (else
                (string-append
                 (indent-line (+ indent 2) "size = " (>clang-name (symbol->string type)) "_calculate_size(" accessor ");")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT0(size);")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT1(size);")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT2(size);")
                 (indent-line (+ indent 2) "buf[ptr ++] = INT3(size);")
                 (indent-line (+ indent 2) (>clang-name (symbol->string type)) "_encode(" accessor ", buf + ptr);")
                 (indent-line (+ indent 2) "ptr += size;")))))
         (indent-line (+ indent 2) "break;")
         (indent-line indent "}")))))

  (define (generate-clang-set-data sname fields)
    (string-append
     (indent-line 0 "static void " sname "_set__data(" (>clang-struct-name sname) " * " sname ", unsigned char * buf, short * dtags, int dlen) {")
     (indent-line 2 "int ptr = 0;")
     (indent-line 2 "int size = 0;")
     (indent-line 2 "for (int i = 0; i < dlen; i ++) {")
     (indent-line 4 "switch (dtags[i]) {")
     (strcat (map (lambda (x) (generate-clang-set-data-action sname x 4)) fields))
     (indent-line 4 "default:")
     (indent-line 6 "break;")
     (indent-line 4 "}")
     (indent-line 2 "}")
     (indent-line 0 "}")))

  (define (generate-clang-encoder sname fields)
    (let ((none-byte-type-count (length (filter (lambda (x) (not (eq? 'byte (field-type x)))) fields))))
      (string-append
       (generate-clang-set-fields sname fields)
       (generate-clang-set-data sname fields)
       (indent-line 0 "void " sname "_encode(" (>clang-struct-name sname)" * " sname ", unsigned char * buf) {")
       (if (> none-byte-type-count 0)
           (string-append
            (indent-line 2 "short dtags[" (number->string none-byte-type-count) "];")
            (indent-line 2 "int dlen = 0;")
            (indent-line 2 "int ptr = " sname "_set__fields(" sname ", buf, dtags, &dlen);")
            (indent-line 2 sname "_set__data(" sname ", buf + ptr, dtags, dlen);"))
           (string-append
            (indent-line 2 sname "_set__fields(" sname ", buf, NULL, NULL);")))
       (indent-line 0 "}"))))
#+end_src
*** 预估解码大小
#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  (define (generate-clang-estimate-size-action field indent)
    (let ((tag (number->string (field-tag field)))
          (type (field-type field)))
      (string-append
       (indent-line indent "case " tag ": {")
       (indent-line (+ indent 2) "int s = INT(buf + ptr);")
       (if (array-type? type)
           (let ((base-type (array-base-type type)))
             (case base-type
               ((byte short int long)
                (string-append
                 (indent-line (+ indent 2) "size += s;")
                 (indent-line (+ indent 2) "ptr += 4 + s;")))
               ((string)
                (string-append
                 (indent-line (+ indent 2) "int count = INT(buf + ptr + 4);")
                 (indent-line (+ indent 2) "int tmp = ptr + 8; ")
                 (indent-line (+ indent 2) "for (int j = 0; j < count; j ++) {")
                 (indent-line (+ indent 4) "int l = INT(buf + tmp);")
                 (indent-line (+ indent 4) "size += l + 1;")
                 (indent-line (+ indent 4) "tmp += l;")
                 (indent-line (+ indent 2) "}")
                 (indent-line (+ indent 2) "ptr += 4 + s;")))
               (else
                (string-append
                 (indent-line (+ indent 2) "int count = INT(buf + ptr + 4);")
                 (indent-line (+ indent 2) "int tmp = ptr + 8; ")
                 (indent-line (+ indent 2) "for (int j = 0; j < count; j ++) {")
                 (indent-line (+ indent 4) "int l = INT(buf + tmp); ")
                 (indent-line (+ indent 4) "size += " (>clang-name (symbol->string base-type)) "_estimate_size(buf + tmp + 4);")
                 (indent-line (+ indent 4) "tmp += l;")
                 (indent-line (+ indent 2) "}")
                 (indent-line (+ indent 2) "ptr += 4 + s;")))))
           (case type
             ((byte)
              (indent-line (+ indent 2) "ptr += 4 + 1;"))
             ((short)
              (indent-line (+ indent 2) "ptr += 4 + 2;"))
             ((int)
              (indent-line (+ indent 2) "ptr += 4 + 4;"))
             ((long)
              (indent-line (+ indent 2) "ptr += 4 + 8;"))
             ((string)
              (string-append
               (indent-line (+ indent 2) "size += s + 1;")
               (indent-line (+ indent 2) "ptr += 4 + s;")))
             (else
              (string-append
               (indent-line (+ indent 2) "size += " (>clang-name (symbol->string type)) "_estimate_size(buf + ptr + 4);")
               (indent-line (+ indent 2) "ptr += 4 + s;")))))
       (indent-line (+ indent 2) "break;")
       (indent-line indent "}"))))

  (define (generate-clang-estimate-size sname fields)
    (string-append
     (indent-line 0 "int " sname "_estimate_size(uint8_t * buf) {")
     (indent-line 2 "int ptr = 0;")
     (indent-line 2 "short tag = 0;")
     (indent-line 2 "short dtags[" (number->string (length fields)) "];")
     (indent-line 2 "int dlen = 0;")
     (indent-line 2 "int size = sizeof(" (>clang-struct-name sname) ");")
     (indent-line 2 "short count = SHORT(buf);")
     (indent-line 2 "ptr += 2;")
     (indent-line 2 "for (short i = 0; i < count; i ++) {")
     (indent-line 4 "short value = SHORT(buf + ptr);")
     (indent-line 4 "ptr += 2;")
     (indent-line 4 "if ((value & 0x01) == 1) {")
     (indent-line 6 "tag += (value - 1) >> 1;")
     (indent-line 4 "} else if (value == 0) {")
     (indent-line 6 "dtags[dlen ++] = tag;")
     (indent-line 6 "tag ++;")
     (indent-line 4 "} else {")
     (indent-line 6 "tag ++;")
     (indent-line 4 "}")
     (indent-line 2 "}")
     (indent-line 2 "for (int i = 0; i < dlen; i ++) {")
     (indent-line 4 "switch (dtags[i]) {")
     (strcat (map (lambda (x) (generate-clang-estimate-size-action x 4)) fields))
     (indent-line 4 "default:")
     (indent-line 6 "break;")
     (indent-line 4 "}")
     (indent-line 2 "}")
     (indent-line 2 "return size;")
     (indent-line 0 "}")))
#+end_src
*** 解碼器
#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm

#+end_src
*** 主體
#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  (define (generate-clang-tightrope-runtime-header path)
    (let ((src "#ifndef _TIGHTROPE_H
  #define _TIGHTROPE_H
  #include <stdint.h>

  #define SHORT(x) ((((int16_t)((uint8_t)(x)[0]) << 8) & 0xFF00) | (((int16_t)((uint8_t)(x)[1])) & 0xFF))
  #define SHORT0(x) (uint8_t)(((x) >> 8) & 0xFF)
  #define SHORT1(x) (uint8_t)((x) & 0xFF)

  #define INT(x) ((((int32_t)((uint8_t)(x)[0]) << 24) & 0xFF000000) | (((int32_t)((uint8_t)(x)[1]) << 16) & 0xFF0000) | (((int32_t)((uint8_t)(x)[2]) << 8) & 0xFF00) | (((int32_t)((uint8_t)(x)[3])) & 0xFF))
  #define INT0(x) (uint8_t)(((x) >> 24) & 0xFF)
  #define INT1(x) (uint8_t)(((x) >> 16) & 0xFF)
  #define INT2(x) (uint8_t)(((x) >> 8) & 0xFF)
  #define INT3(x) (uint8_t)((x) & 0xFF)

  #define LONG(x) ((((int64_t)((uint8_t)(x)[0]) << 56) & 0xFF00000000000000) | (((int64_t)((uint8_t)(x)[1]) << 48) & 0x00FF000000000000) | (((int64_t)((uint8_t)(x)[2]) << 40) & 0x0000FF0000000000) | (((int64_t)((uint8_t)(x)[3]) << 32) & 0x000000FF00000000) | (((int64_t)((uint8_t)(x)[4]) << 24) & 0x00000000FF000000) | (((int64_t)((uint8_t)(x)[5]) << 16) & 0x0000000000FF0000) | (((int64_t)((uint8_t)(x)[6]) << 08) & 0x000000000000FF00) | (((int64_t)((uint8_t)(x)[7])) & 0x00000000000000FF))
  #define LONG0(x) (uint8_t)(((x) >> 56) & 0xFF)
  #define LONG1(x) (uint8_t)(((x) >> 48) & 0xFF)
  #define LONG2(x) (uint8_t)(((x) >> 40) & 0xFF)
  #define LONG3(x) (uint8_t)(((x) >> 32) & 0xFF)
  #define LONG4(x) (uint8_t)(((x) >> 24) & 0xFF)
  #define LONG5(x) (uint8_t)(((x) >> 16) & 0xFF)
  #define LONG6(x) (uint8_t)(((x) >> 8) & 0xFF)
  #define LONG7(x) (uint8_t)((x) & 0xFF)

  int tightrope_padding(short tag, short nexttag, uint8_t * buf, short * count);
  #endif
  "))
      (with-output-to-file
          (string-append path "tightrope.h")
        (lambda ()
          (write-string src))
        (list 'replace))))

  (define (generate-clang-tightrope-runtime-source path)
    (let ((src "#include \"tightrope.h\"

  int tightrope_padding(short tag, short nexttag, uint8_t * buf, short * count) {
    if (tag == nexttag) {
      return 0;
    } else {
      short t = (nexttag - tag) * 2 + 1;
      buf[0] = SHORT0(t);
      buf[1] = SHORT1(t);
      ,* count += 1;
      return 2;
    }
  }
  "))
      (with-output-to-file
          (string-append path "tightrope.c")
        (lambda ()
          (write-string src))
        (list 'replace))))

  (define (generate-clang-tightrope-runtime path)
    (generate-clang-tightrope-runtime-header path)
    (generate-clang-tightrope-runtime-source path))

  (define (generate-clang-serial env struct dir)
    (let ((name (>clang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((includes (string-append "#include <stdlib.h>\n#include <string.h>\n#include \"tightrope.h\"\n#include \"" name ".h\"\n"))
            (calcsize (generate-clang-calculate-size name fields))
            (encoder (generate-clang-encoder name fields))
            (estisize (generate-clang-estimate-size name fields)))
        (with-output-to-file
            (string-append dir name ".c")
          (lambda ()
            (write-string (string-append includes calcsize encoder estisize)))
          (list 'replace)))))

  (define (generate-clang-serials env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (generate-clang-tightrope-runtime path)
      (generate-clang-zero-pack env dir)
      (for-each
       (lambda (entity) (generate-clang-serial env entity path))
       (get-structs env))))
#+end_src
** 輔助函數
#+begin_src scheme :noweb-ref utility
  (define (>clang-name name)
    (let loop ((src (map char-downcase (string->list name)))
               (dst '()))
      (if (null? src)
          (list->string (reverse dst))
          (let ((chr (car src))
                (rest (cdr src)))
            (if (eq? chr #\-)
                (loop rest (cons #\_ dst))
                (loop rest (cons chr dst)))))))

  (define (>clang-struct-name name)
    (string-append (>clang-name name) "_t"))

  (define (>clang-macro-name name)
    (list->string (map char-upcase (string->list name))))

  (define (>clang-type type)
    (case type
      ((byte) "char")
      ((short) "int16_t")
      ((int) "int32_t")
      ((long) "int64_t")
      ((string) "char *")
      (else (>clang-struct-name (symbol->string type)))))

  (define (>clang-accessor sname name)
    (string-append (>clang-name sname) "->" (>clang-name name)))
#+end_src
