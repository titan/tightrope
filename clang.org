* c 後端實現

正在進行中。
** 實體對象
在 Tightrope C 實現中，用結構體來實現數據結構，實體對象的名稱遵循 C 語言的命名規
則，以 "_t" 結尾。實體對象的定義保存在對應的頭文件中，方便各個模塊調用。

#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  <<utility>>

  (define (generate-clang-include field)
    (if (custom-type? (field-type field))
        (string-append "#include \"" (>clang-name (symbol->string (field-type field))) ".h\"\n")
        ""))

  (define (generate-clang-field-declare field)
    (let ((name (>clang-name (field-name field)))
          (type (field-type field)))
      (if (array-type? type)
          (string-append (>clang-type (array-base-type type)) " * " name ";\n    int __" name "_len;")
          (string-append (>clang-type type) " " name ";"))))

  (define (generate-clang-field-setter-declare struct-name field)
    (let ((name (>clang-name (field-name field)))
          (type (field-type field)))
      (if (array-type? type)
          (string-append "void " struct-name "_set_" name "(" (>clang-struct-name struct-name) " *, " (>clang-type (array-base-type type)) " *, int);")
          "")))

  (define (generate-clang-entity struct dir)
    (let ((name (>clang-name (struct-name struct)))
          (fields (struct-fields struct)))
      (let ((macro-name (>clang-macro-name (string-append "_" name "_h")))
            (includes (strcat (map generate-clang-include fields)))
            (sname (>clang-struct-name name))
            (field-decls (strcat (map (lambda (x) (indent-line 4 (generate-clang-field-declare x))) fields)))
            (setters (strcat (map (lambda (x) (indent-line 2 (generate-clang-field-setter-declare name x))) (filter (lambda (y) (array-type? (field-type y))) fields)))))
        (let ((content
               (string-append
                (indent-line 0 "#ifndef " macro-name)
                (indent-line 0 "#define " macro-name)
                (indent-line 0 "#include <stdint.h>")
                includes
                (indent-line 0 "#ifdef __cplusplus")
                (indent-line 0 "extern \"C\" {")
                (indent-line 0 "#endif")
                (indent-line 2 "typedef struct " name " " sname ";")
                (indent-line 2 "struct " name " {")
                field-decls
                (indent-line 2 "};")
                (indent-line 2 "int " name "_calculate_size(" sname " *);")
                (indent-line 2 "void " name "_encode(" sname " *, unsigned char *);")
                (indent-line 2 "int " name "_estimate_size(unsigned char *);")
                (indent-line 2 "void " name "_decode(unsigned char *, " sname " *);")
                setters
                (indent-line 0 "#ifdef __cplusplus")
                (indent-line 0 "}")
                (indent-line 0 "#endif")
                (indent-line 0 "#endif"))))
          (with-output-to-file
              (string-append dir name ".h")
            (lambda ()
              (write-string content))
            (list 'replace))))))

  (define (generate-clang-entities env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (for-each
       (lambda (entity) (generate-clang-entity entity path))
       (get-structs env))))
#+end_src

** 壓縮與解壓
Tightrope 把壓縮和解壓的代碼放到獨立的文件中，供使用者調用。

#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  (define (generate-clang-zero-pack-header path)
    (let ((src "#ifndef _ZEROPACK_H
  #define _ZEROPACK_H
  #ifdef __cplusplus
  extern \"C\" {
  #endif
    int zeropack(unsigned char * src, int len, unsigned char * dst);
    int zerounpack(unsigned char * src, int len, unsigned char * dst);
  #ifdef __cplusplus
  }
  #endif
  #"))
      (with-output-to-file
          (string-append path "zeropack.h")
        (lambda ()
          (write-string src))
        (list 'replace))))

  (define (generate-clang-zero-pack-source path)
    (let ((src "#include <string.h>
  #include \"zeropack.h\"

  int zeropack(unsigned char * src, int len, unsigned char * dst) {
    unsigned char ffcnt = 0;
    int ffpos = 0;
    unsigned char oocnt = 0;
    int oopos = 0;
    int ptr = 1;
    unsigned char bytes[0];
    int bptr = 0;
    unsigned char bitmap = 0;
    int blen = len + ((len % 8) != 0 ? (8 - len % 8): 0);
    unsigned char buf[blen];
    memset(buf, 0, blen);
    memcpy(buf, src, len);
    for (int i = 0, l = blen / 8; i < l; i ++) {
      bptr = 0;
      bitmap = 0;
      for (int j = 0; j < 8; j ++) {
        if (buf[i * 8 + j] != 0) {
          bitmap = bitmap | (1 << (8 - j - 1));
          bytes[bptr ++] = buf[i * 8 + j];
        }
      }
      if (bitmap == 0x00) {
        if (ffcnt > 0) {
          dst[ffpos] = ffcnt;
          ffcnt = 0;
        }
        if (oocnt == 0) {
          dst[ptr ++] = 0x00;
          oopos = ptr ++;
          oocnt ++;
        } else if (oocnt == 0xFF) {
          dst[oopos] = 0xFF;
          dst[ptr ++] = 0x00;
          oopos = ptr ++;
          oocnt = 1;
        } else {
          oocnt ++;
        }
      } else if (bitmap == 0xFF) {
        if (oocnt > 0) {
          dst[oopos] = oocnt;
          oocnt = 0;
        }
        if (ffcnt == 0) {
          dst[ptr ++] = 0xFF;
          ffpos = ptr ++;
          ffcnt ++;
        } else if (ffcnt == 0xFF) {
          dst[ffpos] = 0xFF;
          dst[ptr ++] = 0xFF;
          ffpos = ptr ++;
          ffcnt = 1;
        } else {
          ffcnt ++;
        }
        for (int k = 0; k < bptr; k ++) {
          dst[ptr ++] = bytes[k];
        }
      } else {
        dst[ptr ++] = bitmap;
        if (oocnt > 0) {
          dst[oopos] = oocnt;
          oocnt = 0;
        } else if (ffcnt > 0) {
          dst[ffpos] = ffcnt;
          ffcnt = 0;
        }
        for (int k = 0; k < bptr; k ++) {
          dst[ptr ++] = bytes[k];
        }
      }
    }
    if (oocnt > 0) {
      dst[oopos] = oocnt;
    } else if (ffcnt > 0) {
      dst[ffpos] = ffcnt;
    }

    dst[0] = blen / ptr + (blen % ptr != 0? 1 : 0);

    return ptr;
  }

  int zerounpack(unsigned char * src, int len, unsigned char * dst) {
    int sptr = 1;
    int dptr = 0;
    int cnt = 0;
    while (sptr < len) {
      switch (src[sptr]) {
      case 0:
        cnt = src[sptr + 1];
        for (int i = 0; i < cnt; i ++) {
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
          dst[dptr ++] = 0;
        }
        sptr += 2;
        break;
      case 0xFF:
        cnt = src[sptr + 1];
        memcpy(dst + dptr, src + sptr + 2, cnt * 8);
        dptr += cnt * 8;
        sptr += 2 + cnt * 8;
        break;
      default:
        cnt = 0;
        for (int i = 0; i < 8; i ++) {
          if ((src[sptr] & (1 << (8 - i - 1))) > 0) {
            cnt ++;
            dst[dptr ++] = src[sptr + cnt];
          } else {
            dst[dptr ++] = 0;
          }
        }
        sptr += cnt + 1;
        break;
      }
    }
    return dptr;
  }
  "))
      (with-output-to-file
          (string-append path "zeropack.c")
        (lambda ()
          (write-string src))
        (list 'replace))))

  (define (generate-clang-zero-pack env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (generate-clang-zero-pack-header path)
      (generate-clang-zero-pack-source path)))
#+end_src

** 序列化與反序列化

#+begin_src scheme :exports code :noweb yes :tangle /dev/shm/tightrope-build/clang.scm
  (define (generate-clang-serial env struct dir)
    (let ((name (>clang-name (struct-name struct)))
          (fields (struct-fields struct)))
      '()))

  (define (generate-clang-serials env dir)
    (let ((path dir))
      (if (and (> (string-length path) 0) (not (file-exists? path)))
          (mkdir-p path))
      (generate-clang-zero-pack env dir)
      (for-each
       (lambda (entity) (generate-clang-serial env entity path))
       (get-structs env))))
#+end_src
** 輔助函數
#+begin_src scheme :noweb-ref utility
  (define (>clang-name name)
    (let loop ((src (map char-downcase (string->list name)))
               (dst '()))
      (if (null? src)
          (list->string (reverse dst))
          (let ((chr (car src))
                (rest (cdr src)))
            (if (eq? chr #\-)
                (loop rest (cons #\_ dst))
                (loop rest (cons chr dst)))))))

  (define (>clang-struct-name name)
    (string-append (>clang-name name) "_t"))

  (define (>clang-macro-name name)
    (list->string (map char-upcase (string->list name))))

  (define (>clang-type type)
    (case type
      ((byte) "char")
      ((short) "int16_t")
      ((int) "int32_t")
      ((long) "int64_t")
      ((string) "char *")
      (else (>clang-struct-name (symbol->string type)))))
#+end_src
